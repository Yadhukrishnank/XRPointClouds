// Assets/Shaders/CubeRendering.compute
// Unity 6000.0.33f1 â€” Produces packed float3 Positions (+ optional float4 Colors) for VFX Graph.
// Dispatch groups: ( (_Width+7)/8, (_Height+7)/8, 1 )

#pragma kernel CSMain
#pragma target 5.0

// ---------- Inputs ----------
StructuredBuffer<uint> depthBuffer;     // ushort uploaded as uint from C#

// ---------- Outputs ----------
RWStructuredBuffer<float3> Positions;   // capacity >= _Width * _Height
RWStructuredBuffer<float4> Colors;      // optional, still bound from C#

// GPU counters (1 element each)
RWStructuredBuffer<uint> _ValidCount;   // depth > 0
RWStructuredBuffer<uint> _VisibleCount; // after all culls

// Optional RGB texture (read only)
Texture2D<float4> _ColorTex;

// ---------- Uniforms ----------
uint  _Width, _Height;
float _Fx, _Fy, _Cx, _Cy;
float _Scale;               // visual/world scale applied AFTER meter culling
float _CullMinZ, _CullMaxZ; // METERS
float _CullX, _CullY;       // optional ROI extents (unused here)
float4x4 _PoseMatrix;       // sensor->world
float4x4 _VP;               // camera VP for optional frustum test
int _UseColorTex;           // 1 if _ColorTex is bound
int _DoFrustum;             // 1 = perform frustum test; 0 = skip

// Orientation controls
int _FlipPosX, _FlipPosY;   // flips for geometry (normalized camera coords)
int _FlipRgbX, _FlipRgbY;   // flips for RGB sampling (texture coords)

// 8x8 threads per group
[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height) return;

    const uint u = id.x;
    const uint v = id.y;
    const uint idx = v * _Width + u;

    // 1) Depth in mm -> meters (no scale yet)
    uint zRaw = depthBuffer[idx];
    if (zRaw == 0) return;

    InterlockedAdd(_ValidCount[0], 1);

    float z_m = zRaw * 0.001f;                  // meters
    if (z_m < _CullMinZ || z_m > _CullMaxZ)     // cull in meters to avoid unit mixups
        return;

    // 2) Apply visual/world scale AFTER culling
    float zs = z_m * _Scale;

    // Normalized camera coords
    float xn = ((float)u - _Cx) / _Fx;
    float yn = ((float)v - _Cy) / _Fy;

    if (_FlipPosX != 0) xn = -xn;
    if (_FlipPosY != 0) yn = -yn;

    float x = xn * zs;
    float y = yn * zs;

    float4 world = mul(_PoseMatrix, float4(x, y, zs, 1.0f));

    // (Optional) ROI culling in world space (example only)
    // if (abs(world.x) > _CullX || abs(world.y) > _CullY) return;

    // 3) Optional frustum test
    if (_DoFrustum != 0)
    {
        float4 clip = mul(_VP, world);
        if (clip.w <= 0) return;
        if (abs(clip.x) > clip.w || abs(clip.y) > clip.w || clip.z < -clip.w || clip.z > clip.w)
            return;
    }

    // 4) Compact write
    uint writeIndex;
    InterlockedAdd(_VisibleCount[0], 1, writeIndex);
    Positions[writeIndex] = world.xyz;

    // 5) Optional color
    float4 c = float4(1,1,1,1);
    if (_UseColorTex != 0)
    {
        uint su = (_FlipRgbX != 0) ? (_Width  - 1 - u) : u;
        uint sv = (_FlipRgbY != 0) ? (_Height - 1 - v) : v;
        c = _ColorTex.Load(int3(su, sv, 0)); // integer texel coords, mip=0
    }
    Colors[writeIndex] = c;
}
